#!/usr/bin/python3
# -*- coding: utf-8 -*-

# This file is part of Cockpit.
#
# Copyright (C) 2017 Red Hat, Inc.
#
# Cockpit is free software; you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation; either version 2.1 of the License, or
# (at your option) any later version.
#
# Cockpit is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with Cockpit; If not, see <http://www.gnu.org/licenses/>.

import os
import json
import subprocess
import sys

sys.dont_write_bytecode = True

import task

BOTS = os.path.abspath(os.path.dirname(__file__))
BASE = os.path.normpath(os.path.join(BOTS, ".."))

def run(context, verbose=False, **kwargs):
    cwd = BASE

    def output(*args):
        if verbose:
            sys.stderr.write("+ " + " ".join(args) + "\n")
        return subprocess.check_output(args, cwd=cwd, universal_newlines=True)
    def execute(*args):
        if verbose:
            sys.stderr.write("+ " + " ".join(args) + "\n")
        subprocess.check_call(args, cwd=cwd)

    def changed(filename):
        lines = output("git", "diff", "--", filename).split("\n")
        msgstr = False
        for line in lines:
            if line.startswith("+msgstr ") and not line.endswith('""'):
                if verbose:
                    sys.stderr.write("{0}: {1}\n".format(filename, line[8:]))
                msgstr = True
        return msgstr

    # Make a tree with source and run "update-po" in it... outputs working directory
    line = output("bots/make-source", "update-po")
    work = os.path.abspath(line.strip())

    # Do the various updates
    cmd = [ "make", "upload-pot", "clean-po", "download-po" ]
    if verbose:
        sys.stderr.write("+ " + " ".join(cmd) + "\n")
    subprocess.check_call(cmd, cwd=work)

    branch = None
    user = None
    current_manifest = None
    current_linguas = []
    language_map = {}

    def write_linguas():
        with open("po/LINGUAS", "w", encoding='utf-8') as lngs:
            print("\n".join(current_linguas), file=lngs)

    # Build language map
    with open("po/language_map.txt", "r") as lm:
        for line in lm:
            items = line.strip().split(":")
            language_map[items[0]] = items
            language_map[items[2]] = items

    with open("pkg/shell/manifest.json.in", "r", encoding='utf-8') as mnfst:
        current_manifest = json.load(mnfst)

    with open("po/LINGUAS", "r", encoding='utf-8') as lngs:
        for line in lngs:
            current_linguas.append(line.strip())

    # Remove languages that fall under 50% translated
    files = output("git", "ls-files", "--deleted", "po/")
    for name in files.split("\n"):
        if name.endswith(".po"):
            language = name.split("/")[1][:-3]
            locale = language_map[language][2]
            current_manifest["locales"].pop(locale, None)
            execute("git", "rm", "--", name)
            current_linguas.remove(language)
            write_linguas()
            execute("git", "add", "--", "po/LINGUAS")
            with open("pkg/shell/manifest.json.in", "w", encoding='utf-8') as mnfst:
                text = json.dumps(current_manifest, ensure_ascii=False, indent=4)
                print(text, file=mnfst)
            execute("git", "add", "--", "pkg/shell/manifest.json.in")
            bu = task.branch(context, "po: Drop '{0}' language".format(language),
                             pathspec=None, branch=branch, push=False, **kwargs)
            (user, branch) = bu.split(":")

    # Add languages that got over 50% translated
    files = output("git", "ls-files", "--others", "--exclude-standard", "po/")
    for name in files.split("\n"):
        if name.endswith(".po"):
            language = name.split("/")[1][:-3]
            locale = language_map[language]
            current_manifest["locales"][locale[2]] = locale[1]
            current_manifest["locales"] = dict(sorted(current_manifest["locales"].items()))
            execute("git", "add", "--", name)
            current_linguas.append(language)
            current_linguas.sort()
            write_linguas()
            execute("git", "add", "--", "po/LINGUAS")
            with open("pkg/shell/manifest.json.in", "w", encoding='utf-8') as mnfst:
                text = json.dumps(current_manifest, ensure_ascii=False, indent=4)
                print(text, file=mnfst)
            execute("git", "add", "--", "pkg/shell/manifest.json.in")
            bu = task.branch(context, "po: Add '{0}' language".format(language),
                             pathspec=None, branch=branch, push=False, **kwargs)
            (user, branch) = bu.split(":")

    # Here we have logic to only include files that actually
    # changed translations, and reset all the remaining ones
    files = output("git", "ls-files", "--modified", "po/")
    for name in files.split("\n"):
        if name.endswith(".po"):
            if changed(name):
                execute("git", "add", "--", name)
            else:
                execute("git", "checkout", "--", name)

    # Create a pull request from these changes
    bu = task.branch(context, "po: Update from Fedora Zanata", pathspec="po/",
                     branch=branch, **kwargs)

    if bu:
        task.pull(bu, **kwargs)
    elif branch:
        task.push_branch(user, branch)
        task.pull("{0}:{1}".format(user, branch), **kwargs)


if __name__ == '__main__':
    task.main(function=run, title="Update translations from Fedora Zanata")
